# Task Bonus - Special instructions: RDRAND / RDSEED, RDTSC

## RDRAND and RDSEED

Processors in the x86 family may (most do) have support for random number generation.
Random numbers are very important, especially in security, and the generation of random numbers that cannot be guessed was and is a relevant topic in Computer Science.
Before the appearance of these instructions, random numbers were generated by software, based on the entropy in the system.
Entropy is the amount of random information (it cannot be determined mathematically easily) in the environment.
Entropy is contributed by things such as system temperature, processor frequency at a given moment, cache addresses where writes are made, etc.

`RDRAND' and `RDSEED' hide the whole process of determining the entropy and using it to get a number behind a processor instruction.
The difference between the 2 is how sure the programmer can be that that random number cannot be guessed.
`RDRAND' guarantees that an attacker with finite resources cannot guess the number (that is, the effort required to find out the number is extremely high).
`RDSEED' guarantees that an attacker with infinite resources cannot guess the number.
In addition to these guarantees, the instructions also differ in their duration of execution.
`RDSEED' takes longer and is more likely than `RDRAND' to return a valid number.

## RDTSC

Systems always need to be able to determine how much time has passed between 2 events.
However, the processors in the systems do not have the notion of "second" built in.
Instead, they know the number of clock cycles since they were last reset and the frequency of a clock cycle.
That number of clock cycles is retained in an internal register of the processor, (Time-Stamp Counter - TSC) and can be read using the instruction `RDTSC'.

## Requirement

1) Using the instructions above, implement the `get_rand' function from the `bonus_timegate.asm' file, which returns a 32-bit random number.
This function must not be inspectable using GDB (it must not be possible to use GDB to find the random number).
If the GDB is detected, the function will return 0. (5p)
To be able to test the implementation automatically, insert the **rdrand_here:** label in the code, right before the **rdrand** / **rdseed** instruction.

2) Implement a program that uses the `get_rand' function, to obtain a secret, based on the generated random number and a constant string of characters.
This can be a number, string, etc.
The secret must be generated following complex operations, without the constant string or random number from the secret being easily visible. (minimum 5p)

## Additional specifications
  * HINT: In assembly, instructions have a fixed number of clock cycles, and the execution of several instructions will not vary much, as clock cycles used.
  Instrumenting using GDB brings a significant overhead in terms of clock cycles.
  * In the case of `RDRAND' and `RDSEED' instructions, the validity of the number must be checked in the code.
  Otherwise, points will not be awarded.
  * For the 2nd requirement, more points can be given, if the implementation is unique.
  * The 2nd requirement, being one of creativity, cannot be checked automatically.
  The check will be done manually, by the proofreader.
  Therefore, you will have to describe the implementation in a README.

## References
  * [RDRAND and RDSEED](https://www.intel.com/content/dam/develop/external/us/en/documents/drng-software-implementation-guide-2-1-185467.pdf)
  * [RDTSC, page 547](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-2b- manual.pdf)